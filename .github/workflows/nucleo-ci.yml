permissions:
  contents: write

name: NUCLEO CI (tests natifs, build, artefacts, release, email)

"on":
  push:
    branches: [ "main", "dev" , "CI/CD"]
    tags: [ "v*.*.*" ]
  pull_request:

env:
  ENABLE_S3_UPLOAD: "false"
  ARTEFACT_NAME: nucleo-firmware

jobs:
  native-tests:
    runs-on: ubuntu-latest
    env:
      CC: gcc

    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc make cppcheck lcov
          
      - name: Setup Unity Test Framework
        run: |
          cd test
          # Vérifier si Unity est présent
          if [ ! -f "unity/unity.h" ] || [ ! -f "unity/unity.c" ]; then
            echo "Unity manquant, téléchargement..."
            mkdir -p unity
            # Télécharger Unity depuis le repo officiel
            curl -L https://github.com/ThrowTheSwitch/Unity/raw/master/src/unity.h -o unity/unity.h
            curl -L https://github.com/ThrowTheSwitch/Unity/raw/master/src/unity.c -o unity/unity.c
            curl -L https://github.com/ThrowTheSwitch/Unity/raw/master/src/unity_internals.h -o unity/unity_internals.h
          else
            echo "Unity déjà présent"
          fi

      - name: Cache test dependencies
        uses: actions/cache@v4
        with:
          path: |
            test/unity
            test/build
          key: nucleo-test-${{ runner.os }}-${{ hashFiles('test/**/*.c', 'test/**/*.h', 'test/Makefile') }}

      # --- TESTS → JUnit XML ---
      - name: Run native tests
        run: |
            cd test
            mkdir -p reports
            
            # Exécuter les tests et capturer les résultats
            echo "=== Début des tests NUCLEO ===" > reports/tests_raw.log
            make test-native >> reports/tests_raw.log 2>&1 || true
            echo "=== Fin des tests NUCLEO ===" >> reports/tests_raw.log
            
            # Afficher le contenu pour debug
            echo "Contenu du log de tests:"
            cat reports/tests_raw.log
            
            # Convertir les résultats Unity en format JUnit XML
            python3 - <<'EOF'
            import re, xml.etree.ElementTree as ET
            from datetime import datetime

            # Lire le log des tests
            with open('reports/tests_raw.log', 'r') as f:
                content = f.read()

            print("=== Debug: Contenu du fichier ===")
            print(repr(content[:500]))  # Premiers 500 caractères pour debug
            print("=== Fin debug ===")

            # Parser les résultats Unity - pattern correct observé
            unity_pattern = r'\./(.*?):(\d+):(.*?):(PASS|FAIL)'
            unity_matches = re.findall(unity_pattern, content)

            # Parser les résultats de résumé Makefile
            makefile_success_pattern = r'✅ (.*?): SUCCÈS'
            makefile_fail_pattern = r'❌ (.*?): ÉCHEC'

            success_tests = re.findall(makefile_success_pattern, content)
            failed_tests = re.findall(makefile_fail_pattern, content)

            print(f"Unity matches: {len(unity_matches)}")
            print(f"Makefile success: {len(success_tests)}")
            print(f"Makefile failed: {len(failed_tests)}")

            # Si on a des résultats Unity détaillés, les utiliser
            if unity_matches:
                matches = unity_matches
                print("Utilisation des résultats Unity détaillés")
            else:
                # Sinon, créer des matches basés sur les résultats Makefile
                matches = []
                for test_name in success_tests:
                    matches.append((f"test/{test_name}", "1", test_name, "PASS"))
                for test_name in failed_tests:
                    matches.append((f"test/{test_name}", "1", test_name, "FAIL"))
                print("Utilisation des résultats Makefile")

            print(f"Total matches: {len(matches)}")
            for match in matches[:5]:
                print(f"Match: {match}")

            # Créer XML JUnit
            root = ET.Element('testsuites')
            root.set('name', 'NUCLEO Native Tests')
            root.set('timestamp', datetime.now().isoformat())

            # Grouper par fichier de test
            test_files = {}
            for file_path, line_num, test_name, status in matches:
                if file_path not in test_files:
                    test_files[file_path] = []
                test_files[file_path].append((test_name, status, line_num))

            total_tests = 0
            total_failures = 0

            for file_path, tests in test_files.items():
                suite = ET.SubElement(root, 'testsuite')
                suite.set('name', file_path.replace('/', '_'))
                suite.set('tests', str(len(tests)))

                failures = sum(1 for _, status, _ in tests if status == 'FAIL')
                suite.set('failures', str(failures))
                suite.set('errors', '0')
                suite.set('time', '1.0')

                total_tests += len(tests)
                total_failures += failures

                for test_name, status, line_num in tests:
                    testcase = ET.SubElement(suite, 'testcase')
                    testcase.set('name', test_name)
                    testcase.set('classname', file_path.replace('/', '.'))
                    testcase.set('time', '0.1')

                    if status == 'FAIL':
                        failure = ET.SubElement(testcase, 'failure')
                        failure.set('message', f'Test failed at line {line_num}')
                        failure.text = f'Test {test_name} failed in {file_path}:{line_num}'

            root.set('tests', str(total_tests))
            root.set('failures', str(total_failures))

            # Sauvegarder le XML
            tree = ET.ElementTree(root)
            tree.write('reports/tests.xml', encoding='utf-8', xml_declaration=True)

            print(f"JUnit XML créé avec {total_tests} tests, {total_failures} échecs")
            EOF
            
            # Vérifier que le fichier JUnit a été créé
            if [[ -f reports/tests.xml ]]; then
              echo "✅ JUnit XML créé: $(wc -l < reports/tests.xml) lignes"
              head -5 reports/tests.xml
            else
              echo "❌ Erreur: reports/tests.xml n'a pas été créé"
              ls -la reports/ || echo "Le dossier reports/ n'existe pas"
              exit 1
            fi

      # --- Parse JUnit → Markdown ---
      - name: Build Markdown summary from JUnit
        run: |
          cd test
          python3 - <<'PY'
          import xml.etree.ElementTree as ET, os

          xml_path = 'reports/tests.xml'
          if not os.path.exists(xml_path):
              print(f"Erreur: {xml_path} n'existe pas")
              print("Fichiers dans reports/:")
              if os.path.exists('reports'):
                  print(os.listdir('reports'))
              else:
                  print("Le dossier reports/ n'existe pas")
              exit(1)
          
          tree = ET.parse(xml_path)
          root = tree.getroot()

          # JUnit peut avoir <testsuites> ou un seul <testsuite>
          if root.tag == 'testsuite':
              suites = [root]
          else:
              suites = list(root.findall('testsuite'))

          rows = []
          total = passed = failed = skipped = 0

          def status_of(case):
              if case.find('failure') is not None or case.find('error') is not None:
                  return 'FAIL'
              if case.find('skipped') is not None:
                  return 'SKIP'
              return 'PASS'

          for suite in suites:
              suite_name = (suite.get('name') or 'native').replace('_', '/')
              for case in suite.findall('testcase'):
                  name  = case.get('name') or ''
                  st    = status_of(case)
                  try:
                      dur_s = float(case.get('time') or 0.1)
                  except:
                      dur_s = 0.1
                  dur_s = max(dur_s, 0.001)  # min 0.001s

                  total += 1
                  if st == 'PASS':
                      passed += 1; badge = '✅ PASS'
                  elif st == 'SKIP':
                      skipped += 1; badge = '⚠️ SKIP'
                  else:
                      failed += 1; badge = '❌ FAIL'

                  full_name = f"{suite_name}/{name}" if name else suite_name
                  rows.append((full_name, badge, f"{dur_s:.3f}s"))

          # Écrire le Markdown dans un fichier séparé
          with open('reports/tests.md', 'w', encoding='utf-8') as f:
              f.write("### Tests unitaires NUCLEO (native)\n")
              f.write(f"**Résumé** : {passed} pass · {failed} fail · {skipped} skip · total {total}\n\n")
              f.write("| Test | Statut | Durée |\n")
              f.write("|---|:---:|---:|\n")
              for n,s,t in rows:
                  f.write(f"| `{n}` | {s} | {t} |\n")
          
          print(f"Markdown créé avec succès: {os.path.getsize('reports/tests.md')} bytes")
          PY

      - name: Publish job summary
        run: |
          cd test
          cat reports/tests.md >> $GITHUB_STEP_SUMMARY

      - name: Upload test results
        uses: actions/upload-artifact@v4
        with:
          name: nucleo-test-results
          path: test/reports/

  cppcheck:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install cppcheck + deps
        run: |
          sudo apt-get update
          sudo apt-get install -y cppcheck python3 python3-lxml

      - name: Run cppcheck (HTML if available)
        run: |
          mkdir -p reports/cppcheck_html
          
          # Générer XML temporaire pour le HTML
          cppcheck --std=c99 --enable=all --inline-suppr \
                   --suppress=missingIncludeSystem \
                   --suppress=unusedFunction \
                   --suppress=unmatchedSuppression \
                   -I Core/Inc -I Core/Inc/Services \
                   -I Drivers/STM32F4xx_HAL_Driver/Inc \
                   -I Drivers/CMSIS/Device/ST/STM32F4xx/Include \
                   -I Drivers/CMSIS/Include \
                   -I Middlewares/Third_Party/FreeRTOS/Source/include \
                   -I Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 \
                   --xml --xml-version=2 Core/Src/ 2> /tmp/cppcheck.xml || true
          
          if command -v cppcheck-htmlreport >/dev/null; then
            cppcheck-htmlreport --file=/tmp/cppcheck.xml \
                                --report-dir=reports/cppcheck_html \
                                --source-dir=. || true
          fi
          
          # Supprimer le XML temporaire
          rm -f /tmp/cppcheck.xml
          echo "### Cppcheck NUCLEO (advisory)" >> $GITHUB_STEP_SUMMARY
          echo "Rapport HTML: artefact **nucleo-cppcheck-html** (si généré)." >> $GITHUB_STEP_SUMMARY

      - name: Upload cppcheck HTML
        uses: actions/upload-artifact@v4
        with:
          name: nucleo-cppcheck-html
          path: reports/cppcheck_html/**
          if-no-files-found: ignore

  build-nucleo:
    runs-on: ubuntu-latest
    needs: [native-tests, cppcheck]
    
    steps:
      - uses: actions/checkout@v4

      - name: Install ARM toolchain
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-arm-none-eabi make

      - name: Cache ARM build
        uses: actions/cache@v4
        with:
          path: |
            Debug
            build
          key: nucleo-build-${{ runner.os }}-${{ hashFiles('**/*.c', '**/*.h', 'Makefile') }}

      - name: Build firmware (STM32F411RE)
        run: |
          
          # Créer un Makefile simple pour la compilation
          cat > Makefile <<'MAKEFILE'
          # Makefile simple pour STM32F411RE
          TARGET = DPM2_NUCLEO
          
          # Définir les outils
          PREFIX = arm-none-eabi-
          CC = $(PREFIX)gcc
          AS = $(PREFIX)gcc -x assembler-with-cpp
          CP = $(PREFIX)objcopy
          SZ = $(PREFIX)size
          
          # Définir les flags
          CPU = -mcpu=cortex-m4
          FPU = -mfpu=fpv4-sp-d16
          FLOAT-ABI = -mfloat-abi=hard
          MCU = $(CPU) -mthumb $(FPU) $(FLOAT-ABI)
          
          # Defines
          C_DEFS = -DUSE_HAL_DRIVER -DSTM32F411xE
          
          # Includes
          C_INCLUDES = -ICore/Inc -ICore/Inc/Services
          C_INCLUDES += -IDrivers/STM32F4xx_HAL_Driver/Inc
          C_INCLUDES += -IDrivers/STM32F4xx_HAL_Driver/Inc/Legacy
          C_INCLUDES += -IDrivers/CMSIS/Device/ST/STM32F4xx/Include
          C_INCLUDES += -IDrivers/CMSIS/Include
          C_INCLUDES += -IMiddlewares/Third_Party/FreeRTOS/Source/include
          C_INCLUDES += -IMiddlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2
          C_INCLUDES += -IMiddlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM4F
          
          # Compile flags
          CFLAGS = $(MCU) $(C_DEFS) $(C_INCLUDES) -Os -Wall -fdata-sections -ffunction-sections
          
          # Sources
          C_SOURCES = $(wildcard Core/Src/*.c)
          C_SOURCES += $(wildcard Core/Src/Services/*.c)
          C_SOURCES += $(wildcard Drivers/STM32F4xx_HAL_Driver/Src/*.c)
          C_SOURCES += $(wildcard Middlewares/Third_Party/FreeRTOS/Source/*.c)
          C_SOURCES += $(wildcard Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2/*.c)
          C_SOURCES += $(wildcard Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM4F/*.c)
          C_SOURCES += $(wildcard Middlewares/Third_Party/FreeRTOS/Source/portable/MemMang/*.c)
          
          ASM_SOURCES = Core/Startup/startup_stm32f411retx.s
          
          # Linker script
          LDSCRIPT = STM32F411RETX_FLASH.ld
          
          # Libraries
          LIBS = -lc -lm -lnosys
          LIBDIR =
          LDFLAGS = $(MCU) -specs=nano.specs -T$(LDSCRIPT) $(LIBDIR) $(LIBS) -Wl,-Map=$(TARGET).map,--cref -Wl,--gc-sections
          
          # Default action: build all
          all: $(TARGET).elf $(TARGET).hex $(TARGET).bin
          
          # Object files
          OBJECTS = $(addprefix build/,$(notdir $(C_SOURCES:.c=.o)))
          vpath %.c $(sort $(dir $(C_SOURCES)))
          OBJECTS += $(addprefix build/,$(notdir $(ASM_SOURCES:.s=.o)))
          vpath %.s $(sort $(dir $(ASM_SOURCES)))
          
          build/%.o: %.c Makefile | build
          	$(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=build/$(notdir $(<:.c=.lst)) $< -o $@
          
          build/%.o: %.s Makefile | build
          	$(AS) -c $(CFLAGS) $< -o $@
          
          $(TARGET).elf: $(OBJECTS) Makefile
          	$(CC) $(OBJECTS) $(LDFLAGS) -o $@
          	$(SZ) $@
          
          $(TARGET).hex: $(TARGET).elf | build
          	$(CP) -O ihex $< $@
          	
          $(TARGET).bin: $(TARGET).elf | build
          	$(CP) -O binary -S $< $@
          
          build:
          	mkdir -p $@
          
          clean:
          	-rm -fR build
          	-rm -f $(TARGET).elf $(TARGET).hex $(TARGET).bin $(TARGET).map
          
          .PHONY: all clean
          MAKEFILE
          
          # Compiler le firmware
          make all
          
          # Vérifier que les fichiers ont été créés
          ls -la *.elf *.hex *.bin *.map || echo "Certains fichiers de sortie manquent"

      - name: Package firmware (bin + elf + hex + map + README)
        run: |
          mkdir -p out
          cp -v *.bin out/ 2>/dev/null || echo "Pas de fichier .bin"
          cp -v *.elf out/ 2>/dev/null || echo "Pas de fichier .elf"
          cp -v *.hex out/ 2>/dev/null || echo "Pas de fichier .hex"
          cp -v *.map out/ 2>/dev/null || echo "Pas de fichier .map"
          
          cat > out/README.txt <<'TXT'
          ========== STM32 NUCLEO Firmware Package ==========
          Contenu :
            - DPM2_NUCLEO.bin : image binaire à flasher
            - DPM2_NUCLEO.hex : image Intel HEX pour programmateurs
            - DPM2_NUCLEO.elf : binaire avec symboles (debug, addr2line)
            - DPM2_NUCLEO.map : carte mémoire (diagnostic)

          Flash avec ST-Link :
            st-flash write DPM2_NUCLEO.bin 0x8000000

          Flash avec OpenOCD :
            openocd -f interface/stlink.cfg -f target/stm32f4x.cfg \
                    -c "program DPM2_NUCLEO.hex verify reset exit"

          Debug avec GDB :
            arm-none-eabi-gdb DPM2_NUCLEO.elf
            (gdb) target extended-remote :4242
            (gdb) monitor reset halt
            (gdb) load
            (gdb) continue

          Débugger un backtrace (addr2line) :
            arm-none-eabi-addr2line -pfiaC -e DPM2_NUCLEO.elf 0x08001234 0x08005678 ...
          ====================================================
          TXT
          
          # Nettoyer le nom de branche pour éviter les caractères problématiques
          BRANCH_NAME="${{ github.ref_name || github.sha }}"
          CLEAN_NAME=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9._-]/_/g')
          ZIP="${{ env.ARTEFACT_NAME }}-${CLEAN_NAME}.zip"
          (cd out && zip -r "../$ZIP" .)
          echo "ZIP_FILE=$ZIP" >> $GITHUB_ENV

      - name: Upload firmware ZIP
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ZIP_FILE }}
          path: ${{ env.ZIP_FILE }}

  release:
    runs-on: ubuntu-latest
    needs: build-nucleo
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
      - uses: actions/checkout@v4
      
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          
      - name: Find ZIP
        id: findzip
        run: |
          ZIP="$(find artifacts -name '*.zip' | head -n1 | xargs basename)"
          echo "zip=$ZIP" >> $GITHUB_OUTPUT
          
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          tag_name: ${{ github.ref_name }}
          name: "NUCLEO Firmware ${{ github.ref_name }}"
          body: ${{ github.event.head_commit.message }}
          files: artifacts/**/${{ steps.findzip.outputs.zip }}
          draft: false
          prerelease: false

  email:
    runs-on: ubuntu-latest
    needs: [build-nucleo]
    if: always()
    steps:
      - name: Compose email body (simple text)
        id: body
        run: |
          if [[ "${{ needs.build-nucleo.result }}" == "success" ]]; then
            STATUS="✅ SUCCESS"; ICON="✅"
          else
            STATUS="❌ FAILED"; ICON="❌"
          fi
          BRANCH_OR_TAG="${GITHUB_REF##*/}"
          COMMIT="${GITHUB_SHA:0:8}"
          ACTIONS_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          # Corps de l'email simple
          {
            echo "body<<EMAIL_BODY_EOF"
            echo "$ICON Build STM32 NUCLEO DPM2: $STATUS"
            echo "🔀 Ref: ${BRANCH_OR_TAG}"
            echo "🔖 Commit: ${COMMIT}"
            echo ""
            echo "🧪 Tests: Voir le Summary GitHub Actions pour les détails des tests unitaires"
            echo ""
            if [[ "${GITHUB_REF}" == refs/tags/* ]] && [[ "${{ needs.build-nucleo.result }}" == "success" ]]; then
              echo "📦 Release: https://github.com/${{ github.repository }}/releases/tag/${BRANCH_OR_TAG}"
            else
              echo "📋 Details: ${ACTIONS_URL}"
            fi
            echo ""
            echo "📑 Cppcheck: artefact 'nucleo-cppcheck-html' (si généré)"
            echo "📦 Firmware ZIP: artefact '${{ env.ARTEFACT_NAME }}-${BRANCH_OR_TAG}.zip' (ou SHA)"
            echo "EMAIL_BODY_EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Send email
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_HOST }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          from: ${{ secrets.MAIL_FROM }}
          to: ${{ secrets.MAIL_TO }}
          subject: "STM32 NUCLEO DPM2 CI • ${{ needs.build-nucleo.result == 'success' && 'OK' || 'FAIL' }} • ${{ github.ref_name || github.sha }}"
          secure: false
          body: ${{ steps.body.outputs.body }}